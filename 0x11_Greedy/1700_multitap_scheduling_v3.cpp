#include <bits/stdc++.h>
using namespace std;

int N, K;
int M[109], T[109], E[109];
int ans;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> N >> K;

    for (int i = 1; i <= K; i++) {
        cin >> E[i];
        T[E[i]] = i;
    }

    int j, k;
    for (int i = 1; i <= K; i++) {
        int mx = 0, mxidx = 0;
        for (j = 0; j < N; j++) {
            if (!M[j] || M[j] == E[i]) {
                M[j] = E[i];
                break;
            }
        }
        
        if (j < N) continue;

        ans++;
        
        for (int j = 0; j < N; j++) {
            for (k = i+1; k <= K; k++) {
                if (E[k] != M[j]) continue;
                if (k > mx) {
                    mx = k;
                    mxidx = j;
                }
                break;
            }
            
            if (k <= K) continue;
            
            mx = 0;
            mxidx = j;
            break;
        }

        M[mxidx] = E[i];
    }

    cout << ans;
}
// v2에서 문제 발견한 지점 :
// 3 8
// 1 2 3 4 2 3 4 1 일 때,
// 제일 먼저 빠져도 되는 (마지막으로 사용하는 시점이 가장 앞인) 용품을 먼저 빼는 방식을 사용하면
// x x x 2뽑4 3뽑2 2뽑3 x x 해야함.
// 근데 많은 경우의 수를 테스트 해보려고 4를 넣을 때 1을 뽑아봤더니
// x x x 1뽑4 x x x 4뽑1 2번만 하면 된다는 미친 경우의 수를 발견함.
// 그래서 가까운 미래에 사용될 예정이면 놔두는 게 최선이라는 가설을 세우고 코드를 짬.
// 하지만 미래에 사용될 예정이 없는 물건이 있다면 그게 빠지는 것이 이득임.
// 미루는 것이 최선의 방법이 될 수 있다니;;
// 뭔가 신기함 그냥.. 이런 문제는 내가 짠 코드와 변수의 범위를 보고 시간복잡도가 너무 차이난다 싶으면 다시 생각해야하나.. 솔직히 거의 찍은 거라서 흠..
// 이 문제 같은 경우 N, K 값의 최댓값이 100인데 v2처럼 구현하면 O(N2)임.
// 근데 100이면 O(N4)까지도 커버 가능함.

// OPT 알고리즘 알아보기
// 그냥 이게 opt임.. 어쩌라고 근데 증명이 참 ㅈ같네 그냥 알아내야하나보네 ㅅㅂ 뭐야이게 귀류법으로 밖에 증명이 안돼? 그럼 그냥 발견해야하잖아
// 귀류법으로 증명을 할려면 어떤 새로운 알고리즘을 가져와서 이게 opt보다 더 좋을걸? 아니네 아님말고
// 맞으면 귀류법에 위배되므로 opt보다 더 좋은 알고리즘 발견! 시2ㅏㅂㄹ 뭐야 이게