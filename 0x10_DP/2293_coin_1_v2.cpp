// 보류 너무 어렵다 ㅋㅋ 250704
#include <bits/stdc++.h>
using namespace std;

int n, k;
bool D[10004][10004];
bool nums[10004];

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> k;

    for (int i = 1; i <= n; i++) {
        int tmp; cin >> tmp;
        nums[tmp] = 1;
    }

    for (int i = 1; i <= k; i++) {
        if (nums[i]) D[i][1] = 1;

        for (int j = 1; j <= i-1; j++) {
            if (!nums[j]) continue;
            for (int p = 1; p <= i-j; p++) {
                // cout << D[i-j][p] << '\n';
                if (!D[i-j][p]) continue;
                // cout << "i = " << i << ", j = " << j << ", p = " << p << '\n';
                D[i][p+1] = 1;
            }
        }
    }

    int ans = 0;
    for (int i = 1; i <= k; i++) {
        cout << D[k][i] << ' ';
        ans += D[k][i];

        // for (int t = 1; t <= k; t++) {
        //     cout << D[i][t] << ' ';
        // }
        // cout << '\n';
    }
    cout << '\n';

    // cout << D[2][2];

    cout << ans;
}
// 이 문제 보니까 1,2,3 더하기랑 똑같네
// 아니네 시2ㅏㅂㄹ
// D[i] = i원이 되도록 하는 경우의 수의 합
// 이러면 그냥 해봐 차례대로
// 3 10 1 2 5 input일 때
// D[1] = 1 (1)
// D[2] = 2 (1 1), (2)
// D[3] = 2 (1 1 1), (1 2)
// D[4] = 3 (1 1 1 1), (1 1 2), (2 2)
// D[5] = 4 (1 1 1 1 1), (1 1 1 2), (1 2 2), (5)
// D[6] = 5 (1 1 1 1 1 1), (1 1 1 1 2), (1 1 2 2), (2 2 2), (1 5)
// D[7] = 6 (1 1 1 1 1 1 1), (1 1 1 1 1 2), (1 1 1 2 2), (1 2 2 2), (1 1 5), (2 5)
// 흠 동전 개수가 같으면서 다른 경우는 없다는 걸 알 수 있음. 다시 개수 순으로 재정렬 해볼까?
// D[1] = 1 (1)
// D[2] = 2 (2), (1 1)
// D[3] = 2 (1 2), (1 1 1)
// D[4] = 3 (1 1 1 1), (1 1 2), (2 2)
// D[5] = 4 (1 1 1 1 1), (1 1 1 2), (1 2 2), (5)
// D[6] = 5 (1 1 1 1 1 1), (1 1 1 1 2), (1 1 2 2), (2 2 2), (1 5)
// D[7] = 6 (1 1 1 1 1 1 1), (1 1 1 1 1 2), (1 1 1 1)
// 흠 동전 개수가 같으면서 다른 경우는 없다는 걸 알 수 있음. 다시 개수 순으로 재정렬 해볼까?
// 아니네 1 1 1 2 5도 10이고 2 2 2 2 2도 10이네 시2발 아 ㅈ같네 ㅋㅋ ㅋ ㅋ ㅋㅋ ㅋㅋ ㅋ 


// D[i][j] = i원이 되도록 하는 경우의 수의 합 (오름차순으로 정렬 했을 때 j가 맨 뒤에 오는 경우)로 할려고 했는데
// 10000 * 10000 = 100'000'000 (100메가바이트라서 안됨)